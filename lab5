[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=20745350&assignment_repo_type=AssignmentRepo)


# Lab 05 — MQTT en Raspberry Pi + microcontrolador con MicroPython

## Integrantes
- [David Santiago Puentes Cárdenas — 99225](https://github.com/Monstertrox)  
- [Juan David Arias Bojacá — 107394](https://github.com/juandariasb-ai)

## 1. Objetivos de aprendizaje
1. Comprender la arquitectura y funcionamiento de **MQTT** (broker, clientes, modelo pub/sub).  
2. Instalar y configurar **Mosquitto** en Raspberry Pi como broker MQTT.  
3. Implementar un **servidor Flask** en Raspberry Pi, desplegado con **Gunicorn**, para interactuar con el broker MQTT.  
4. Programar un microcontrolador (ESP32 o Raspberry Pi Pico W) con **MicroPython** para enviar/recibir mensajes MQTT.  
5. Controlar un LED mediante mensajes MQTT enviados desde el servidor Flask. 

## 2. Introducción
**MQTT** (Message Queue Telemetry Transport) es un protocolo ligero de comunicación basado en el modelo **pub/sub**.  
En este laboratorio:  
- **Mosquitto** actúa como broker central.  
- Una aplicación **Flask + Gunicorn** en Raspberry Pi funge como cliente/publicador-suscriptor.  
- El microcontrolador (ESP32 o Pico W) se suscribe al broker y controla un **LED** físico según los mensajes recibidos.  

<p align="center">
 <img src="../figs/lab05/mqtt.png" alt="MQTT esquema" width=400>
</p>


## 3) Arquitectura y diagrama

Flujo de datos:  

**Usuario (HTTP POST) → Flask (Gunicorn) → Mosquitto (broker MQTT) → MicroPython (suscriptor) → LED**

![Diagrama del flujo](src/mqtt_flujo.png)

# 4) Estructura sugerida del repositorio

.
├─ README.md
├─ src/
│ ├─ mqtt_flujo.png # Diagrama de la arquitectura
│ ├─ app.py # Servidor Flask (publicador MQTT)
│ └─ main.py # Script MicroPython (suscriptor y control LED)


---

## 5) Instalación y configuración

### 5.1. Acceso por SSH
```bash
ssh usuario@IP_DE_LA_PI
hostname -I   # Para ver IP de la Raspberry

5.2. Instalar Mosquitto en Raspberry Pi
sudo apt update
sudo apt install mosquitto mosquitto-clients -y
sudo systemctl enable mosquitto
sudo systemctl start mosquitto

5.3. Instalar dependencias Python
pip3 install flask paho-mqtt gunicorn

5.4. Crear app.py (Flask + MQTT)
from flask import Flask, request, jsonify
import paho.mqtt.publish as publish

app = Flask(__name__)
BROKER = "localhost"
TOPIC = "micro/led/control"

@app.route("/led", methods=["POST"])
def led_control():
    data = request.json
    estado = data.get("estado")
    if estado in ["ON", "OFF"]:
        publish.single(TOPIC, estado, hostname=BROKER)
        return jsonify({"msg": f"LED -> {estado}"}), 200
    return jsonify({"error": "Estado inválido"}), 400

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)

5.5. Ejecutar con Gunicorn
gunicorn -w 2 -b 0.0.0.0:5000 app:app

6) Código en MicroPython (main.py)

Ejemplo para ESP32/Pico W:

import network
import time
from umqtt.simple import MQTTClient
from machine import Pin

# Config WiFi
WIFI_SSID = "SSID"
WIFI_PASS = "PASSWORD"

# Config MQTT
BROKER = "IP_RASPBERRY"
TOPIC = b"micro/led/control"

# LED en GPIO 2 (ajustar según placa)
led = Pin(2, Pin.OUT)

# Conectar WiFi
wlan = network.WLAN(network.STA_IF)
wlan.active(True)
wlan.connect(WIFI_SSID, WIFI_PASS)
while not wlan.isconnected():
    time.sleep(0.5)
print("Conectado WiFi:", wlan.ifconfig())

# Callback
def on_msg(topic, msg):
    print("Mensaje:", msg)
    if msg == b"ON":
        led.value(1)
    elif msg == b"OFF":
        led.value(0)

# Cliente MQTT
client = MQTTClient("micropython_client", BROKER)
client.set_callback(on_msg)
client.connect()
client.subscribe(TOPIC)

print("Suscrito a", TOPIC)

while True:
    client.wait_msg()

7) Acceso y operación

API Flask: http://IP_DE_LA_PI:5000/led

Ejemplo de prueba:

curl -X POST -H "Content-Type: application/json" \
-d '{"estado":"ON"}' http://IP_DE_LA_PI:5000/led


Respuesta esperada:

{"msg": "LED -> ON"}


Microcontrolador imprime en consola:

Mensaje: ON
LED encendido

8) Validaciones y manejo de errores

Flask: solo acepta "ON" y "OFF".

Broker: verificar que mosquitto esté corriendo (systemctl status mosquitto).

MicroPython: revisar credenciales WiFi y dirección IP de la Raspberry.

9) Pruebas rápidas (E2E)

Conectividad: ping IP_DE_LA_PI

Flask activo: acceder a http://IP_DE_LA_PI:5000/led

Broker activo: mosquitto_sub -h localhost -t micro/led/control

Publicación: usar curl y verificar que el mensaje llega al suscriptor.

Acción física: el LED responde según "ON"/"OFF".

10) Mejoras opcionales

Añadir dashboard web en Flask con botones ON/OFF.

Guardar logs de mensajes MQTT en archivo local o base de datos.

Controlar múltiples actuadores en distintos tópicos.

Proteger API Flask con autenticación.

11) Conclusiones

La arquitectura MQTT permite comunicación eficiente entre Raspberry Pi y microcontroladores.

Flask expone una API REST sencilla que integra sistemas web con IoT.

Gunicorn asegura un despliegue más estable y concurrente que el servidor nativo de Flask.

MicroPython ofrece una forma ligera y práctica de controlar hardware con mensajes MQTT.

12) Créditos y referencias

Mosquitto MQTT

Flask

Gunicorn

MicroPython
